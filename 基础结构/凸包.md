
# 关于凸关系

最值对偶函数表示

```rs
f1 = a↗︎ => gen { b => R(a, b) }.max()
f2 = b↗︎ => gen { a => R(a, b) }.max()

f1(a) >= b <=> f2(b) >= a <=> R(a, b)
```

点对表示

```rs
points = { (a, b) => R(a, b) }.paretos(.max, .max)

points.any((a0, b0) => a <= a0 && b <= b0) <=> R(a, b)
```

注：点对表示可能更精简，但最值函数最便于修改。

# 递增子序列

```rs
mod ascending_subseqs {
    max_len(seq: [ℕ*]) =
        seq.subsequences().filter($.is_sorted()).map($.len()).max()
    
    max_len(seq + [a]) = 
        max(max_len(seq), seq.subsequences().filter($.is_sorted() && $.all(<= a)).map($.len() + 1).max())
    
    max_len_max(seq, a↗︎)
        = seq.subsequences().filter($.is_sorted() && $.all(<= a)).map($.len()).max()
        = gen { len => seq.subsequences().any($.is_sorted() && $.all(<= a) && $.len() == len) }.max()
        = gen { len => max_len_max_inverse(seq)[len] <= a }.max()

    // 转化凸包方向
    max_len_max_inverse(seq)[len : 0..=max_len(seq)]
        = gen { a => seq.subsequences(len).any($.is_sorted() && $.all(<= a)) }.min()
        = seq.subsequences(len).filter($.is_sorted()).map($.last() || 0).min()

    max_len_max_inverse(seq + [c])[len↘ : 0..=max_len(seq + [c])]
        = min(max_len_max_inverse(seq)[len], if max_len_max_inverse(seq)[len - 1] <= c try c)
        = if max_len_max_inverse(seq)[len - 1] <= c && max_len_max_inverse(seq)[len] > c { c }
          else { max_len_max_inverse(seq)[len] }

    // 转化为二分搜索形式
    max_len_max_inverse(seq + [c])
        = if let len = bisearch(max_len_max_inverse(seq), $ > c) {
            max_len_max_inverse(seq)[len => c]
        } else {
            max_len_max_inverse(seq) + [c]
        }
}
```

# 正方类

## 直方图正方

```rs
mod histograms_squares {
    max_square_size(histo: ℕ*)
        = histo.slices().map($.min() * $.len()).max()

    max_square_size(histo + [a])
        = max(max_square_size(histo), max_square_postfixes(histo + [a]))

    max_square_postfixes(histo)
        = histo.postfixes().map($.min() * $.len()).max()
        = max_square_postfixes_paretos(histo).map($.0 * $.1).max()
    
    max_square_postfixes_paretos(histo) 
        = histo.postfixes().pareto_max($.min(), $.len())
    
    max_square_postfixes_paretos(histo + [a])
        = (histo.postfixes() + [a]).pareto_max($.min(), $.len())
        = max_square_postfixes_pareto(histo).map($.(1 => $.1 + 1)).push_foldr_break((a, b) => if b ⊑ a try (b.0, a.1), (a, 1))
}
```

[LeetCode-84](https://leetcode.com/problems/largest-rectangle-in-histogram/).

## 平面正方

[LeetCode-85](https://leetcode.com/problems/maximal-rectangle/)
