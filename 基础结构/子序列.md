
# 0-1 背包

```rs
bag01(bag: ℕ*, cap: ℕ)
    = bag.combinations(cap).map($.sum()).max()

bag01(bag + [n]: ℕ*, cap: ℕ)
    = (bag + [n]).combinations(cap).map(x => x.sum()).max()
    = (bag.combinations(cap) + bag.combinations(cap - 1).map($ + [n])).map($.sum()).max()
    = max(bag01(bag, cap), bag.combinations(cap - 1).map($.sum()) + n)
    = max(bag01(bag, cap), bag01(bag, cap - 1) + n)
```

# 回文子序列问题

```rs
mod palindrome_subseqs {
    max_len(text: char*)
        = text.subsequences()
            .filter($.is_palindrome())
            .map($.len())
            .max()

    max_len([a] + text + [b] : char*)
        = max(max_len(text),
            text.subsequences().map([a] + $).filter($.is_palindrome()).map($.len()).max()
            text.subsequences().map($ + [b]).filter($.is_palindrome()).map($.len()).max()
            text.subsequences().map([a] + $ + [b]).filter($.is_palindrome()).map($.len()).max()
        )
        = max(
            max_len([a] + text),
            max_len(text + [b]),
            if a == b { max_len(text) + 2 } else { 0 },
        )
}
```

# 公共子序列

```rs
mod common_subseqs {
    max_len(s1: char*, s2: char*)
        = s.subsequences().filter($.is_subsequence(s2)).map($.len()).max()
    max_len(s1 + [a], s2 + [b])
        = if a == b { max_len(s1, s2) + 1 }
          else { max(max_len(s1 + [a], s2), max_len(s1, s2 + [b])) }
}
```

```rs
mod common_subseqs {
    max_mul(s1: ℤ*, s2: ℤ*)
        = s1.subsquence_of_len(s2.len()).map(
            $.zip(s2).map($.1 * $.2).sum()
        ).max()
    
    max_mul(s1 + [a]: ℤ*, s2 + [b]: ℤ*)
        = max(
            max_mul(s1, s2) + a * b,
            max_mul(s1, s2 + [b]),
        )
}
```
