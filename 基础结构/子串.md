

# KMP 算法

```rs
mod slice_matching {
    max_len_suffix_prefix(pattern: char*)
        = pattern.suffixes(!=).find($.prefix_of(pattern)).map($.len()).unwarp_or(0)
    
    max_len_suffix_prefix(pattern + [c])
        = pattern.suffixes(!=).find(
            $.prefix_of(pattern) && (pattern[k] == c)
        ).map($.len()).unwarp_or(0)
        = max_len_suffix_prefix(pattern) as k in
            if pattern[k] == c: k + 1
            else: pattern[:k].suffixes(!=).find(
                $.prefix_of(pattern) && (pattern[k] == c)
            ).map($.len()).unwarp_or(0)
        = max_len_suffix_prefix(pattern) as k in
            if pattern[k] == c: k + 1
            else: max_len_suffix_prefix(pattern[:k] + [c])

    max_len_suffix_prefix2(text: char*, pattern: char*) :: ℕ
        = text.suffixes().find($.prefix_of(pattern)).map($.len()).unwarp()
    
    max_len_suffix_prefix2(text + [c], pattern)
        = max_len_suffix_prefix2(text, pattern) as k in
            if pattern[k] == c: k + 1
            else: max_len_suffix_prefix(pattern[:k] + [c])
}
```

# 最大回文前缀

```rs
mod palindrome_prefix {
    max_len(text: char*) = slice_matching::max_len_suffix_prefix2(text.reversed(), text)
}
```

